@page "/try"
@using BlazorMonaco.Editor
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using System.Reflection
@using System.Text
@using static BluehillNuGetPages.Packages
@inject HttpClient Http

<h1>Try</h1>

<p>You can try the following packages on this page:</p>

<ul>
    <li><a href="@Hangul">Bluehill.Hangul</a></li>
    <li><a href="@Deconstructors">Bluehill.Deconstructors</a></li>
    <li><a href="@StringExtensions">Bluehill.StringExtensions</a></li>
</ul>

<h2>Input code</h2>

<p>
    <button class="btn btn-primary" @onclick="hangulExample">Hangul Example</button>
    <button class="btn btn-primary" @onclick="deconstructorsExample">Deconstructors Example</button>
    <button class="btn btn-primary" @onclick="stringExtensionsExample">StringExtensions Example</button>
</p>

<StandaloneCodeEditor @ref="sce" ConstructionOptions="ConstructionOptions"/>
<br/>
<p>
    @if (!isLoading)
    {
        <button class="btn btn-primary" @onclick="runCode">Run</button>
    }
</p>

<h2>Output</h2>

<pre><code>@output?.ToString()</code></pre>

<h2>Return value</h2>

<pre><code>@returnValue</code></pre>

@code {

    static Try()
    {
        // For some unknown reason, you can't call Console.WriteLine(int) from your script unless I call it here.
        Console.WriteLine(0);
    }

    private static readonly StandaloneEditorConstructionOptions Seco = new()
    {
        AutomaticLayout = true,
        Language = "csharp",
        Minimap = new()
        {
            Enabled = false
        },
        ScrollBeyondLastLine = false
    };

    private static Task<IEnumerable<MetadataReference>>? references;

    private static readonly SyntaxTree StaticTree = CSharpSyntaxTree.ParseText("""
                                                                               // <auto-generated />
                                                                               global using System;
                                                                               global using Bluehill;
                                                                               global using Bluehill.Hangul;
                                                                               global using Bluehill.Deconstructors;
                                                                               using System.Reflection;
                                                                               [assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
                                                                               """,
        CSharpParseOptions.Default.WithLanguageVersion(LanguageVersion.Preview).WithKind(SourceCodeKind.Script));

    private StandaloneCodeEditor sce = null!;
    private StringBuilder? output;
    private object? returnValue;
    private bool isLoading;

    private static StandaloneEditorConstructionOptions ConstructionOptions(StandaloneCodeEditor arg) => Seco;

    // ReSharper disable InconsistentNaming
    private async Task<IEnumerable<MetadataReference>> createReferences()
    {
        string[] assemblyNames = ["System.Runtime", "netstandard", "System.Console", "Bluehill.Hangul", "Bluehill.Deconstructors.List", "Bluehill.StringExtensions"];
        List<MetadataReference> mrs = [];

        foreach (var assemblyName in assemblyNames)
        {
            var stream = await Http.GetStreamAsync($"/ref-assemblies/{assemblyName}.dll");

            mrs.Add(MetadataReference.CreateFromStream(stream));
        }

        return mrs;
    }

    private async Task hangulExample() =>
        await sce.SetValue("""
                           const string cheolsu = "철수";
                           const string gildong = "길동";
                           const char gyul = '귤';

                           Console.WriteLine($"{cheolsu.IGa()} 밥을 먹는다.");
                           Console.WriteLine($"{gildong.EunNeun()} 날쌔다.");
                           Console.WriteLine(gyul.Choseong());

                           """);

    private async Task deconstructorsExample() =>
        await sce.SetValue("""
                           int[] ints = [1, 2, 3, 4, 5];
                           var (one, two, three, four, five) = ints;

                           Console.WriteLine(one);

                           """);

    private async Task stringExtensionsExample() =>
        await sce.SetValue("""
                           const string str = "The Quick Brown Fox Jumps Over The Lazy Dog";

                           Console.WriteLine(str.Left(3));
                           Console.WriteLine(str.Right(3));
                           Console.WriteLine(str.CountOccurrences("The"));
                           Console.WriteLine(str.SplitPart(' ', 5));

                           """);

    private void runCode() => _ = Task.Run(compileAndRunCode);

    private async Task compileAndRunCode()
    {
        var oldOut = Console.Out;

        try
        {
            await InvokeAsync(() =>
            {
                isLoading = true;
                output = null;

                StateHasChanged();
            });

            var value = await sce.GetValue();

            if (string.IsNullOrWhiteSpace(value))
            {
                return;
            }

            references ??= createReferences();
            var st = CSharpSyntaxTree.ParseText(value, CSharpParseOptions.Default.WithLanguageVersion(LanguageVersion.Preview).WithKind(SourceCodeKind.Script));
            var c = CSharpCompilation.Create(Guid.NewGuid().ToString("N"), [st, StaticTree], await references);
            await using MemoryStream ms = new();
            var er = c.Emit(ms);

            if (!er.Success)
            {
                await InvokeAsync(() => { returnValue = new InvalidOperationException(string.Join("\n", er.Diagnostics.Select(d => $"{d.Id}: {d.GetMessage()}"))); });

                return;
            }

            ms.Seek(0, SeekOrigin.Begin);

            var asm = Assembly.Load(ms.ToArray());
            var scriptType = asm.GetType("Script");
            var contructor = scriptType?.GetConstructor(BindingFlags.Instance | BindingFlags.Public, []);

            if (contructor is null)
            {
                await InvokeAsync(() => { returnValue = new InvalidOperationException("Could not find script type constructor."); });

                return;
            }

            var instance = contructor.Invoke(null);
            var entryPoint = scriptType!.GetMethod("<Initialize>", BindingFlags.Instance | BindingFlags.NonPublic);

            if (entryPoint is null)
            {
                await InvokeAsync(() => { returnValue = new InvalidOperationException("Could not find script entry point method."); });

                return;
            }

            await using StringWriter sw = new();
            await InvokeAsync(() => output = sw.GetStringBuilder());

            Console.SetOut(sw);

           await InvokeAsync(async () => returnValue = await (Task<object?>)entryPoint.Invoke(instance, null)! ?? "(Not returned)");
        } finally
        {
            Console.SetOut(oldOut);

            await InvokeAsync(() =>
            {
                isLoading = false;

                StateHasChanged();
            });
        }
    }

}
